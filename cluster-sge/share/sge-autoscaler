#!/bin/bash
################################################################################
##
## Alces Clusterware - Handler support script
## Copyright (C) 2016 Stephen F. Norledge and Alces Software Ltd.
##
################################################################################
setup() {
    local a xdg_config
    IFS=: read -a xdg_config <<< "${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
    for a in "${xdg_config[@]}"; do
        if [ -e "${a}"/clusterware/config.vars.sh ]; then
            source "${a}"/clusterware/config.vars.sh
            break
        fi
    done
    if [ -z "${cw_ROOT}" ]; then
        echo "$0: unable to locate clusterware configuration"
        exit 1
    fi
    kernel_load
}

_collate_group_dimensions() {
    local dims groups g

    groups=()
    _gather_groups() {
        while [ "$1" != "--" ]; do shift; done
        groups+=($(member_find_tag "aws_group" "$5"))
    }
    member_each _gather_groups
    groups=($(printf "%s\n" "${groups[@]}" | sort -u | tr '\n' ' '))
    log "[autoscaler:groups] Found groups: ${groups[*]}"

    dims=()
    for g in "${groups[@]}"; do
        dims+=("$("${_JO}" Name=AutoScalingGroupName Value=${g})")
    done

    "${_JO}" -a "${dims[@]}"
}

_set_job_metrics() {
    # for all known scaling groups, set job metrics
    local dims tmpfile

    dims="$(_collate_group_dimensions)"
    tmpfile="$(mktemp /tmp/sge-autoscaler.XXXXXXXX)"

    qstat -u '*' | awk 'NR > 2{print $5}' | sort | uniq -c | (
        t=0
        metrics=()
        seen_states=()
        if [ -f "${cw_ROOT}"/var/lib/db/cluster-sge/statetab ]; then
            known_states=($(cat "${cw_ROOT}"/var/lib/db/cluster-sge/statetab))
        fi
        while read c s; do
            log "[autoscaler:metrics] Found ${c} jobs in state '${s}'"
            t=$(($t+$c))
            metrics+=($("${_JO}" MetricName=JobStatus_$s Value=$c Unit=Count "Dimensions=${dims}"))
            seen_states+=($s)
        done

        for state in "${known_states[@]}"; do
            if [[ " ${seen_states[*]} " != *" ${state} "* ]]; then
                log "[autoscaler:metrics] No jobs in previously seen state '${state}'"
                metrics+=($("${_JO}" MetricName=JobStatus_$state Value=0 Unit=Count "Dimensions=${dims}"))
            fi
        done

        known_states+=(${seen_states[@]})
        log "[autoscaler:metrics] Update known states table"
        mkdir -p "${cw_ROOT}"/var/lib/db/cluster-sge
        printf "%s\n" "${known_states[@]}" | sort -u > "${cw_ROOT}"/var/lib/db/cluster-sge/statetab

        log "[autoscaler:metrics] Found ${t} jobs total"
        metrics+=($("${_JO}" MetricName=JobTotal Value=$t Unit=Count "Dimensions=${dims}"))
        "${_JO}" -a "${metrics[@]}" > "${tmpfile}"
    )

    log "[autoscaler:metrics] Sending metric data to cloudwatch"
    cat "${tmpfile}" | _log_blob "metrics"

    "${_AWS}" --region "${cw_INSTANCE_aws_region}" \
      cloudwatch put-metric-data \
      --namespace "ALCES-SGE" \
      --metric-data file://${tmpfile} 2>&1 | _log_blob "metrics:aws"

    rm -f "${tmpfile}"
}

_empty_nodes() {
    ruby_run <<RUBY
require 'rexml/document'
doc = REXML::Document.new(IO.popen('qstat -f -xml -q bynode.q@*'))
doc.each_element('//Queue-List') do |el|
  used = el.text('slots_used')
  name = el.text('name')
  state = el.text('state')
  if state != 'S' && used == "0"
    puts name.split('@').last
  end
end
RUBY
}

_unexhausted_nodes() {
    local node nodelist ctime
    nodelist="$*"
    for node in ${nodelist}; do
        ctime=$(member_get_member_tag "${node}" "aws_ctime")
        if [ "${ctime}" ]; then
            ruby_run <<RUBY
require 'time'
delta = Time.now - Time.parse('${ctime}')
print "${node} " if delta % 3600 <= 3180
RUBY
        else
            # unable to find ctime, assume unexhausted
            echo -n "${node} "
        fi
    done
}

_log_blob() {
    local prefix
    prefix="$1"
    log_blob "${cw_CLUSTER_SGE_log}" "autoscaler:${prefix}"
}

_shoot_node() {
    local node instanceid group
    node="$1"
    group="$2"
    instanceid=$(member_get_member_tag "${node}" "aws_instanceid")

    log "[autoscaler:shoot] Removing scale-in protection for ${node} (${instanceid})"
    # deprotect the instance
    "${_AWS}" --region "${cw_INSTANCE_aws_region}" \
      autoscaling set-instance-protection \
      --instance-ids "${instanceid}" \
      --auto-scaling-group-name "${group}" \
      --no-protected-from-scale-in 2>&1 | _log_blob "autoscaling:aws"

    # scale in the capacity
    log "[autoscaler:shoot] Reading capacity of scaling group ${group}"
    capacity=$("${_AWS}" --region "${cw_INSTANCE_aws_region}" \
                 autoscaling describe-auto-scaling-groups \
                 --auto-scaling-group-names "${group}" | \
                 grep DesiredCapacity | awk '{print $2}' | tr -d ',')
    log "[autoscaler:shoot] Reducing capacity of scaling group ${group} from ${capacity} to $((${capacity}-1))"
    "${_AWS}" --region "${cw_INSTANCE_aws_region}" \
      autoscaling update-auto-scaling-group \
      --auto-scaling-group-name "${group}" \
      --desired-capacity $((${capacity}-1)) 2>&1 | _log_blob "autoscaling:aws"

    # tell the instance to halt
    member_ip="$(member_ip ${node})"
    master_ip="$(network_get_network_address ${member_ip})"
    log "[autoscaler:shoot] Instructing ${node} (${member_ip}) to halt"
    handler_broadcast sge-halt "${master_ip}" "${member_ip}" &>/dev/null
}

_scale_in() {
    # determine which nodes are viable to reap
    # algorithm is:
    #  - nodes that are currently empty
    #  - nodes that are within last 10 minutes of current hour
    #    (i.e. those that may incur additional cost between now and
    #    the next run)
    empty_nodes="$(_empty_nodes)"
    empty_nodes=($(echo "${empty_nodes}" | tr '\n' ' '))
    log "[autoscaler:scale-in] Found empty nodes: ${empty_nodes[*]}"

    for node in "${empty_nodes[@]}"; do
        group=$(member_get_member_tag "${node}" "aws_group")
        if [ "${group}" ]; then
            log "[autoscaler:scale-in] Disabling queues on ${node} (in group: ${group})"
            # for each empty node, disable the queues while we're deciding
            # whether we're going to shoot them or not.
            qmod -d "*@${node}" > /dev/null
        fi
    done

    unexhausted_nodes=" $(_unexhausted_nodes ${empty_nodes[@]}) "
    for node in "${empty_nodes[@]}"; do
        group=$(member_get_member_tag "${node}" "aws_group")
        if [ "${group}" ]; then
            if [[ "$unexhausted_nodes" == *" $node "* ]]; then
                # this node is not exhausted, reenable the queue
                log "[autoscaler:scale-in] Enabling queues on ${node} (not exhausted)"
                qmod -e "*@${node}" > /dev/null
            else
                # time for this one to go away
                log "[autoscaler:scale-in] Shooting node: ${node}"
                _shoot_node "${node}" "${group}"
            fi
        fi
    done
}

main() {
    files_load_config instance-aws config/cluster
    files_load_config cluster-sge

    log_set_default "${cw_CLUSTER_SGE_log}"
    log "[autoscaler] Performing job metric scan"
    _set_job_metrics
    log "[autoscaler] Performing scale-in check"
    _scale_in
}

. /etc/profile.d/alces-clusterware.sh
setup

module purge
module use "${cw_ROOT}"/etc/modules
module load services/gridscheduler

require member
require files
require ruby
require handler
require network
require log

PATH=$PATH:/sbin

_JO="${cw_ROOT}"/opt/jo/bin/jo
_AWS="${cw_ROOT}"/opt/aws/bin/aws

main "$@"
