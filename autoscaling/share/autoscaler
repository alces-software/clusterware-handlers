#!/bin/bash
################################################################################
##
## Alces Clusterware - Handler support script
## Copyright (C) 2016 Stephen F. Norledge and Alces Software Ltd.
##
################################################################################
setup() {
    local a xdg_config
    IFS=: read -a xdg_config <<< "${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
    for a in "${xdg_config[@]}"; do
        if [ -e "${a}"/clusterware/config.vars.sh ]; then
            source "${a}"/clusterware/config.vars.sh
            break
        fi
    done
    if [ -z "${cw_ROOT}" ]; then
        echo "$0: unable to locate clusterware configuration"
        exit 1
    fi
    kernel_load
}

_unexhausted_nodes() {
    local node nodelist ctime
    nodelist="$*"
    for node in ${nodelist}; do
        ctime=$(member_get_member_tag "${node}" "aws_ctime")
        if [ "${ctime}" ]; then
            ruby_run <<RUBY
require 'time'
delta = Time.now - Time.parse('${ctime}')
print "${node} " if delta % 3600 <= 3180
RUBY
        else
            # unable to find ctime, assume unexhausted
            echo -n "${node} "
        fi
    done
}

_collate_group_dimensions() {
    local dims groups g

    groups=()
    _gather_groups() {
        while [ "$1" != "--" ]; do shift; done
        groups+=($(member_find_tag "aws_group" "$5"))
    }
    member_each _gather_groups
    groups=($(printf "%s\n" "${groups[@]}" | sort -u | tr '\n' ' '))
    log "[autoscaler:groups] Found groups: ${groups[*]}"

    dims=()
    for g in "${groups[@]}"; do
        dims+=("$("${cw_ROOT}"/opt/jo/bin/jo Name=AutoScalingGroupName Value=${g})")
    done
    if [ "${#dims}" -gt 0 ]; then
        "${cw_ROOT}"/opt/jo/bin/jo -a "${dims[@]}"
    fi
}

_cores_for_group() {
    local group_cores groups_cores g
    group="$1"

    groups_cores=()
    _gather_group_cores() {
        local group
        while [ "$1" != "--" ]; do shift; done
        group=$(member_find_tag "aws_group" "$5")
        if [ "${group}" ]; then
            groups_cores+=(${group}:$(member_find_tag "aws_group_cores" "$5"))
        fi
    }
    member_each _gather_group_cores
    groups_cores=($(printf "%s\n" "${groups_cores[@]}" | sort -u | tr '\n' ' '))
    log "[autoscaler:cores_for_group] Found cores for groups: ${groups_cores[*]}"

    if [ ${#group_cores[@]} -gt 1 -a -n "${group}" ]; then
        log "[autoscaler:cores_for_group] Looking for group: ${group}"
        for g in "${groups_cores[@]}"; do
            if [[ $g == ${group}:* ]]; then
                group_cores=$(echo "${g}" | cut -f2 -d":")
                log "[autoscaler:cores_for_group] Found group '${group}' has cores: ${group_cores}"
            fi
        done
    else
        group_cores=$(echo "${groups_cores[0]}" | cut -f2 -d":")
        log "[autoscaler:cores_for_group] Selecting first group '${groups_cores[0]}' with cores: ${group_cores}"
    fi

    if [ "${group_cores}" ]; then
        echo "${group_cores}"
    else
        return 1
    fi
}

_shoot_node() {
    local aws_exit_code node instanceid group
    node="$1"
    group="$2"
    instanceid=$(member_get_member_tag "${node}" "aws_instanceid")

    # scale in the capacity
    log "[autoscaler:shoot] Shooting node ${instanceid} in group ${group}"
    set -o pipefail
    "${cw_ROOT}"/opt/aws/bin/aws --region "${cw_INSTANCE_aws_region}" \
                autoscaling terminate-instance-in-auto-scaling-group \
                --instance-id ${instanceid} \
                --should-decrement-desired-capacity 2>&1 | _log_blob "autoscaling:aws"
    aws_exit_code=$?
    set +o pipefail
    return ${aws_exit_code}
}

_set_job_metrics() {
    # for all known scaling groups, set job metrics
    local dims tmpfile scheduler cores_per_node job_total_var job_total
    local job_queue_var job_queue job_run_var job_run
    local cores_req_var cores_req nodes_req_var nodes_req

    dims="$(_collate_group_dimensions)"
    tmpfile="$(mktemp /tmp/autoscaler.XXXXXXXX)"
    cores_per_node="$(_cores_for_group)"

    for scheduler in "${_SCHEDULERS[@]}"; do
        log "[autoscaler:metrics] Retrieving job state data for scheduler: ${scheduler}"
        ${scheduler}_parse_job_states "${tmpfile}" "${cores_per_node}"
        cat "${tmpfile}" | _log_blob "metrics"
        . "${tmpfile}"
        job_total_var="${scheduler}_job_total"
        job_total=$((${job_total:-0}+${!job_total_var:-0}))
        job_run_var="${scheduler}_job_run"
        job_run=$((${job_run:-0}+${!job_run_var:-0}))
        job_queue_var="${scheduler}_job_queue"
        job_queue=$((${job_queue:-0}+${!job_queue_var:-0}))
        cores_req_var="${scheduler}_cores_req"
        cores_req=$((${cores_req:-0}+${!cores_req_var:-0}))
        nodes_req_var="${scheduler}_nodes_req"
        nodes_req=$((${nodes_req:-0}+${!nodes_req_var:-0}))
    done

    metrics=()
    metrics+=($("${_JO}" MetricName=JobTotal Value=${job_total:-0} Unit=Count "Dimensions=${dims}"))
    metrics+=($("${_JO}" MetricName=JobRun Value=${job_run:-0} Unit=Count "Dimensions=${dims}"))
    metrics+=($("${_JO}" MetricName=JobQueue Value=${job_queue:-0} Unit=Count "Dimensions=${dims}"))
    metrics+=($("${_JO}" MetricName=CoresReq Value=${cores_req:-0} Unit=Count "Dimensions=${dims}"))
    metrics+=($("${_JO}" MetricName=NodesReq Value=${nodes_req:-0} Unit=Count "Dimensions=${dims}"))
    "${_JO}" -a "${metrics[@]}" > "${tmpfile}"

    # Send: JobTotal, JobRun, JobPending, CoresRequired, NodesRequired
    log "[autoscaler:metrics] Sending metric data to cloudwatch"
    cat "${tmpfile}" | _log_blob "metrics"

    result=$("${_AWS}" --region "${cw_INSTANCE_aws_region}" \
                       cloudwatch put-metric-data \
                       --namespace "ALCES-SCHEDULING" \
                       --metric-data file://${tmpfile} 2>&1)
    if echo "${result}" | grep -q AccessDenied; then
        log "[autoscaler:metrics:aws] Access denied for PutMetricData; disabling."
        mkdir -p "${cw_ROOT}"/var/lib/db/autoscaler
        echo "disabled" > "${cw_ROOT}"/var/lib/db/autoscaler/disable-set_job_metrics
    else
        echo "${result}" | _log_blob "metrics:aws"
    fi

    rm -f "${tmpfile}"
}

_empty_nodes() {
    local scheduler empty_nodes
    empty_nodes=()
    for scheduler in "${_SCHEDULERS[@]}"; do
        empty_nodes+=($(${scheduler}_empty_nodes))
    done
    echo "${empty_nodes[@]}" | tr ' ' '\n' | sort | uniq -d | tr '\n' ' '
}

_log_blob() {
    local prefix
    prefix="$1"
    log_blob "" "autoscaler:${prefix}"
}

_scale_in() {
    # determine which nodes are viable to reap
    # algorithm is:
    #  - nodes that are currently empty
    #  - nodes that are within last 10 minutes of current hour
    #    (i.e. those that may incur additional cost between now and
    #    the next run)
    empty_nodes="$(_empty_nodes)"
    empty_nodes=($(echo "${empty_nodes}" | tr '\n' ' '))
    log "[autoscaler:scale-in] Found empty nodes: ${empty_nodes[*]}"

    # for each empty node, disable the queues while we're deciding
    # whether we're going to shoot them or not.
    for node in "${empty_nodes[@]}"; do
        group=$(member_get_member_tag "${node}" "aws_group")
        if [ "${group}" ]; then
            log "[autoscaler:scale-in] Disabling queues on ${node} (in group: ${group})"
            # disable for each scheduler
            for scheduler in "${_SCHEDULER[@]}"; do
                ${scheduler}_disable_node "${node}"
            done
        fi
    done

    unexhausted_nodes=" $(_unexhausted_nodes ${empty_nodes[@]}) "
    for node in "${empty_nodes[@]}"; do
        group=$(member_get_member_tag "${node}" "aws_group")
        if [ "${group}" ]; then
            if [[ "$unexhausted_nodes" == *" $node "* ]]; then
                # this node is not exhausted, reenable the queue
                log "[autoscaler:scale-in] Enabling queues on ${node} (not exhausted)"
                # enable for each scheduler
                for scheduler in "${_SCHEDULER[@]}"; do
                    ${scheduler}_enable_node "${node}"
                done
            else
                log "[autoscaler:scale-in] Attempting to shoot node: ${node}"
                if ! _shoot_node "${node}" "${group}"; then
                    log "[autoscaler:scale-in] Unable to shoot node, re-enabling queues"
                    # enable for each scheduler
                    for scheduler in "${_SCHEDULER[@]}"; do
                        ${scheduler}_enable_node "${node}"
                    done
                fi
            fi
        fi
    done
}

_setup_schedulers() {
    local a scheduler
    _SCHEDULERS=()
    for a in "${cw_ROOT}"/var/lib/scheduler/*; do
        if [ -f "$a" ]; then
            . "${a}"
            scheduler=$(basename "$a" .functions.sh)
            if type ${scheduler}_features &>/dev/null && \
                    [[ "$(${scheduler}_features)" == *':autoscaling:'* ]]; then
                _SCHEDULERS+=(${scheduler})
            fi
        fi
    done
    log "[autoscaler:setup_schedulers] Found autoscaling-capable scheduler(s): ${_SCHEDULERS[*]}"
}

main() {
    if files_load_config --optional instance-aws config/cluster; then
        _setup_schedulers
        if [ ! -f "${cw_ROOT}"/var/lib/db/autoscaler/disable-set_job_metrics ]; then
            log "[autoscaler] Performing job metric scan"
            _set_job_metrics
        else
            log "[autoscaler] Skipping metric scan (currently disabled)"
        fi

        if [ "${cw_INSTANCE_aws_autoscaling}" == "enabled" ]; then
            log "[autoscaler] Performing scale-in check"
            _scale_in
        else
            log "[autoscaler] Autoscaling is disabled"
        fi
    fi
}

setup

require member
require files
require handler
require log
require ruby

PATH=$PATH:/sbin

_JO="${cw_ROOT}"/opt/jo/bin/jo
_AWS="${cw_ROOT}"/opt/aws/bin/aws

log_set_default "/var/log/clusterware/autoscaler.log"

main "$@"
