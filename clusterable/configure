#!/bin/bash
setup() {
    local a xdg_config
    IFS=: read -a xdg_config <<< "${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
    for a in "${xdg_config[@]}"; do
        if [ -e "${a}"/clusterware/config.vars.sh ]; then
            source "${a}"/clusterware/config.vars.sh
            break
        fi
    done
    export cw_ROOT=${cw_ROOT:-/opt/clusterware}
    source ${cw_ROOT}/lib/functions/core.functions.sh
}

main() {
    # Bail out if we're already configured (this is a reboot)
    if [ -d "${cw_ROOT}/etc/config/cluster" ]; then
        exit 0
    fi

    # Bail out if we can't locate the config file
    if [ ! -f "${cw_ROOT}/etc/config.yml" ]; then
        exit 1
    fi

    # Parse YAML file into something useful
    mkdir -p "${cw_ROOT}/etc/config/cluster/serf"
    ruby_run <<RUBY
require 'yaml'
require 'json'

def write_file(name, content)
  File.write("${cw_ROOT}/etc/config/cluster/#{name}",content)
end

config = YAML.load_file('${cw_ROOT}/etc/config.yml')['cluster']

h = { discover: config['uuid'] }
write_file('serf/cluster.json', h.to_json)

tags = config['tags'] || {}
h = { tags: tags.merge({ role: config['role'] }) }
write_file('serf/tags.json', h.to_json)

instance_vars = []
instance_vars << %(cw_NODE_role="#{config['role']}")
instance_vars << %(cw_CLUSTER_uuid="#{config['uuid']}")
instance_vars << %(cw_CLUSTER_quorum="#{config['quorum']}")
config['tags'].each do |k,v|
  instance_vars << %(cw_NODE_tag_#{k.upcase}="#{v}")
end
write_file('instance.vars.sh', instance_vars.join("\n"))
RUBY

    cp "${cw_ROOT}/etc/config/cluster/serf"/*.json "${cw_ROOT}/etc/serf"

    # Enable serf service for future boots and start it up
    distro_enable_service clusterware-serf
    distro_start_service clusterware-serf
}

setup

require ruby
require distro

main "$@"
