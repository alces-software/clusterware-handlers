#!/bin/bash
################################################################################
##
## Alces Clusterware - Handler hook
## Copyright (C) 2015 Stephen F. Norledge and Alces Software Ltd.
##
################################################################################
setup() {
    local a xdg_config
    IFS=: read -a xdg_config <<< "${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
    for a in "${xdg_config[@]}"; do
        if [ -e "${a}"/clusterware/config.vars.sh ]; then
            source "${a}"/clusterware/config.vars.sh
            break
        fi
    done
    if [ -z "${cw_ROOT}" ]; then
        echo "$0: unable to locate clusterware configuration"
        exit 1
    fi
    kernel_load
}

_member_purge() {
    type member_purge &>/dev/null && member_purge
}

_fetch_cluster_value() {
    local key default_value
    key="$1"
    default_value="$2"
    ruby_run <<RUBY
require 'yaml'

config = YAML.load_file('${cw_ROOT}/etc/config.yml')['cluster']
puts config['${key}'] || '${default_value}'
RUBY
}

_preconfigure_node() {
    local autoscaling machine_type tags
    if network_is_ec2; then
        autoscaling=$(_fetch_cluster_value autoscaling autodetect)
        echo "[setup-aws] Autoscaling configured as: ${autoscaling}"
        eval $(network_fetch_ec2_document | \
                 ${_JQ} -r \
                        '"region=\(.region)"','"ctime=\(.pendingTime)"','"instanceid=\(.instanceId)"')
        machine_type="$(network_fetch_ec2_metadata instance-type 1)"
        cat <<EOF > "${cw_ROOT}"/etc/config/cluster/instance-aws.rc
cw_INSTANCE_aws_region="${region}"
cw_INSTANCE_aws_ctime="${ctime}"
cw_INSTANCE_aws_instanceid="${instanceid}"
cw_INSTANCE_aws_autoscaling="${autoscaling}"
cw_INSTANCE_aws_machinetype="${machine_type}"
cw_INSTANCE_aws_account_hash="$(network_ec2_hashed_account)"
EOF
        cp "$(handler_dir)"/etc/meta.aws.rc "${cw_ROOT}"/etc/meta.d/aws.rc
        tags=(tags[aws_instanceid]=${instanceid})
        tags+=(tags[aws_machinetype]=${machine_type})
        echo "Setting EC2 tags: ${tags[@]}"
        "${_JO}" "${tags[@]}" > "${cw_ROOT}"/etc/serf/tags-clusterable-ec2.json
    fi

    if [ "${cw_CLUSTERABLE_manage_ssh_config}" == "true" ]; then
        cat <<EOF >> /etc/ssh/sshd_config

AuthorizedKeysCommand ${cw_ROOT}/libexec/share/clusterware-key-manager
AuthorizedKeysCommandUser root
HostbasedAuthentication yes
IgnoreRhosts no
EOF
        distro_restart_service sshd
    fi
}

_preconfigure_master() {
    local short_name
    echo "Installing Clusterware periodic cronjob: ${cw_ROOT}/libexec/share/trigger-periodic"
    echo "*/5 * * * * root ${cw_ROOT}/libexec/share/trigger-event periodic >/dev/null 2>&1" > /etc/cron.d/clusterware-clusterable-trigger-periodic

    if [ "${cw_CLUSTERABLE_manage_genders}" == "true" ]; then
        if [ -f "${cw_ROOT}"/etc/genders ]; then
            short_name="$(hostname -s)"
            if ! grep -q "^${short_name}" "${cw_ROOT}"/etc/genders; then
                echo "${short_name} master,masters,cluster,all" >> "${cw_ROOT}"/etc/genders
            fi
        fi
    fi

    if [ "${cw_CLUSTERABLE_manage_ssh_config}" == "true" ]; then
        mkdir -p /root/.ssh
        chmod 0700 /root/.ssh
        cat <<EOF > /root/.ssh/config
Host *
  HostbasedAuthentication yes
EOF
    fi

    if [[ "$cw_DIST" == "el"* ]]; then
        yum makecache
    fi
}

_parse_config() {
    # Parse YAML file into something useful
    ruby_run <<RUBY
require 'yaml'
require 'json'

def write_file(name, content, *args)
  File.write("${cw_ROOT}/etc/config/cluster/#{name}",content,*args)
end

def setup_cluster_identity(config)
  if identity = config['identity']
    config['uuid'] ||=
      # try and extract anything that looks like a UUID from the identity
      if identity =~ /([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})/i
        config['uuid'] = \$1
      else
        # otherwise assume the identity is unique and can serve as UUID input
        config['uuid'] = \`uuid -v5 0103f694-c5a8-5779-af10-3668872f329d "#{identity}"\`.chomp
      end

    config['token'] ||=
      # generate a token from the identity
      \`uuid -v5 0103f694-c5a8-5779-af10-3668872f329d "#{identity}" | base64 | cut -c1-16\`.chomp
  end
end

def deep_merge(target, source)
  target.merge(source) do |key, old, new|
    if Hash === old && Hash === new
      deep_merge(old, new)
    elsif Array === old && Array === new
      old.concat(new).uniq
    else
      new
    end
  end
end

defaults =
  begin
    if File.exist?('${cw_ROOT}/etc/defaults.yml')
      YAML.load_file('${cw_ROOT}/etc/defaults.yml')
    end
  rescue
    {}
  end

config = deep_merge(defaults || {}, YAML.load_file('${cw_ROOT}/etc/config.yml'))
File.write('${cw_ROOT}/etc/config.yml', config.to_yaml)

config = config['cluster']

setup_cluster_identity(config)

if config['master']
  h = { retry_join: [config['master']] }
  write_file('serf/join.json', h.to_json)
end

uuid = config['uuid'] || \`uuid -v4\`.chomp

h = { discover: uuid }
write_file('serf/cluster.json', h.to_json)

if config['interface']
  h = { interface: config['interface'] }
  write_file('serf/interface.json', h.to_json)
end

tags = config['tags'] || {}
h = { tags: tags.merge({ role: config['role'] }) }
write_file('serf/tags.json', h.to_json)

if config['token']
  h = { rpc_auth: config['token'] }
  write_file('serf/auth.json', h.to_json, perm: 0600)
end

cluster_vars = []
cluster_vars << %(cw_CLUSTER_uuid="#{uuid}")
if config['master']
  cluster_vars << %(cw_CLUSTER_master="#{config['master']}")
end
if config['name']
  cluster_vars << %(cw_CLUSTER_name="#{config['name']}")
end
if config['interface']
  cluster_vars << %(cw_CLUSTER_iface="#{config['interface']}")
end
cluster_vars << %(cw_CLUSTER_quorum="#{config['quorum'] || 1}")
cluster_vars << %(cw_CLUSTER_service_url="#{config['service_url']}")
write_file('cluster.vars.sh', cluster_vars.join("\n"))
write_file('config.rc', cluster_vars.join("\n"))

auth_vars = []
if config['token']
  auth_vars << %(cw_CLUSTER_auth_token="#{config['token']}")
end
write_file('auth.rc', auth_vars.join("\n"), perm: 0600)

instance_vars = []
instance_vars << %(cw_INSTANCE_role="#{config['role']}")
instance_vars << %(cw_INSTANCE_log="#{config['log'] || '/var/log/clusterware/instance.log'}")
tags.each do |k,v|
  instance_vars << %(cw_INSTANCE_tag_#{k.upcase.tr('-','_')}="#{v}")
end
if config['hyperthreading']
  instance_vars << %(cw_INSTANCE_hyperthreading="#{config['hyperthreading']}")
end
write_file('instance.vars.sh', instance_vars.join("\n"))
write_file('instance.rc', instance_vars.join("\n"))
RUBY
}

_configure_hyperthreading() {
    case "${cw_INSTANCE_hyperthreading}" in
        enabled)
            ${_ALCES} configure hyperthreading enable 2>&1
            ;;
        disabled)
            ${_ALCES} configure hyperthreading disable 2>&1
            ;;
    esac
}

_write_network_config() {
    if network_has_metadata_service 1; then
        cat <<EOF > "${cw_ROOT}"/etc/network.rc
cw_NETWORK_public_hostname="$(network_get_public_hostname)"
cw_NETWORK_public_ip="$(network_get_public_address)"
EOF
    else
        hn="$(network_get_public_hostname 0)"
        if [ "${hn}" ]; then
            echo "cw_NETWORK_public_hostname=\"${hn}\"" > "${cw_ROOT}"/etc/network.rc
        fi
        echo "cw_NETWORK_public_ip=\"$(network_get_public_address)\"" >> "${cw_ROOT}"/etc/network.rc
    fi
}

_preconfigure_boot() {
    files_load_config instance config/cluster
    # Purge any known existing members in advance of rejoining the
    # cluster service ring.
    _member_purge
    _configure_hyperthreading
    _write_network_config
}

main() {
    # Bail out if we're already configured (this is a reboot)
    if [ -d "${cw_ROOT}/etc/config/cluster" ]; then
        _preconfigure_boot
        exit 0
    fi

    # Bail out if we can't locate the config file
    if [ ! -f "${cw_ROOT}/etc/config.yml" ]; then
        exit 1
    fi

    mkdir -p "${cw_ROOT}/etc/config/cluster/serf"
    _parse_config
    cp -p "${cw_ROOT}/etc/config/cluster/serf"/*.json "${cw_ROOT}/etc/serf"

    files_load_config --optional clusterable
    cw_CLUSTERABLE_manage_ssh_config=${cw_CLUSTERABLE_manage_ssh_config:-true}
    cw_CLUSTERABLE_manage_genders=${cw_CLUSTERABLE_manage_genders:-true}

    _preconfigure_boot
    if [ "${cw_INSTANCE_role}" == "master" ]; then
        _preconfigure_master
    fi
    _preconfigure_node
}

setup

require ruby
require distro
require handler
require member
require files
require network

_JQ="${cw_ROOT}"/opt/jq/bin/jq
_JO="${cw_ROOT}"/opt/jo/bin/jo
_ALCES="${cw_ROOT}"/bin/alces

handler_tee main "$@"
