#!/bin/bash
################################################################################
##
## Alces Clusterware - Handler hook
## Copyright (C) 2015 Stephen F. Norledge and Alces Software Ltd.
##
################################################################################
setup() {
    local a xdg_config
    IFS=: read -a xdg_config <<< "${XDG_CONFIG_HOME:-$HOME/.config}:${XDG_CONFIG_DIRS:-/etc/xdg}"
    for a in "${xdg_config[@]}"; do
        if [ -e "${a}"/clusterware/config.vars.sh ]; then
            source "${a}"/clusterware/config.vars.sh
            break
        fi
    done
    if [ -z "${cw_ROOT}" ]; then
        echo "$0: unable to locate clusterware configuration"
        exit 1
    fi
    kernel_load
}

_member_purge() {
    type member_purge &>/dev/null && member_purge
}

_setup_aws() {
    local autoscaling machine_type
    autoscaling=$(
        ruby_run <<RUBY
require 'yaml'

config = YAML.load_file('${cw_ROOT}/etc/config.yml')['cluster']

if config['autoscaling'] == 'enabled'
  puts 'enabled'
elsif config['autoscaling'] == 'disabled'
  puts 'disabled'
else
  puts 'autodetect'
end
RUBY
              )
    echo "[setup-aws] Autoscaling configured as: ${autoscaling}"
    if network_is_ec2; then
        eval $(network_fetch_ec2_document | \
                 ${_JQ} -r \
                        '"region=\(.region)"','"ctime=\(.pendingTime)"','"instanceid=\(.instanceId)"')
        machine_type="$(network_fetch_ec2_metadata instance-type 1)"
        cat <<EOF > "${cw_ROOT}"/etc/config/cluster/instance-aws.rc
cw_INSTANCE_aws_region="${region}"
cw_INSTANCE_aws_ctime="${ctime}"
cw_INSTANCE_aws_instanceid="${instanceid}"
cw_INSTANCE_aws_autoscaling="${autoscaling}"
cw_INSTANCE_aws_machinetype="${machine_type}"
EOF
        tags=(tags[aws_instanceid]=${instanceid})
        tags+=(tags[aws_machinetype]=${machine_type})
        echo "Setting EC2 tags: ${tags[@]}"
        "${_JO}" "${tags[@]}" > "${cw_ROOT}"/etc/serf/tags-clusterable-ec2.json
    fi
}

main() {
    # Purge any known existing members in advance of rejoining the
    # cluster service ring.
    _member_purge

    # Bail out if we're already configured (this is a reboot)
    if [ -d "${cw_ROOT}/etc/config/cluster" ]; then
        exit 0
    fi

    # Bail out if we can't locate the config file
    if [ ! -f "${cw_ROOT}/etc/config.yml" ]; then
        exit 1
    fi

    # Parse YAML file into something useful
    mkdir -p "${cw_ROOT}/etc/config/cluster/serf"

    ruby_run <<RUBY
require 'yaml'
require 'json'

def write_file(name, content, *args)
  File.write("${cw_ROOT}/etc/config/cluster/#{name}",content,*args)
end

def setup_cluster_identity(config)
  if identity = config['identity']
    config['uuid'] ||=
      # try and extract anything that looks like a UUID from the identity
      if identity =~ /([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})/i
        config['uuid'] = \$1
      else
        # otherwise assume the identity is unique and can serve as UUID input
        config['uuid'] = \`uuid -v5 0103f694-c5a8-5779-af10-3668872f329d "#{identity}"\`.chomp
      end

    config['token'] ||=
      # generate a token from the identity
      \`uuid -v5 0103f694-c5a8-5779-af10-3668872f329d "#{identity}" | base64 | cut -c1-16\`.chomp
  end
end

config = YAML.load_file('${cw_ROOT}/etc/config.yml')['cluster']

setup_cluster_identity(config)

if config['master']
  h = { retry_join: [config['master']] }
  write_file('serf/join.json', h.to_json)
end

uuid = config['uuid'] || \`uuid -v4\`.chomp

h = { discover: uuid }
write_file('serf/cluster.json', h.to_json)

if config['interface']
  h = { interface: config['interface'] }
  write_file('serf/interface.json', h.to_json)
end

tags = config['tags'] || {}
h = { tags: tags.merge({ role: config['role'] }) }
write_file('serf/tags.json', h.to_json)

if config['token']
  h = { rpc_auth: config['token'] }
  write_file('serf/auth.json', h.to_json, perm: 0600)
end

cluster_vars = []
cluster_vars << %(cw_CLUSTER_uuid="#{uuid}")
if config['master']
  cluster_vars << %(cw_CLUSTER_master="#{config['master']}")
end
if config['name']
  cluster_vars << %(cw_CLUSTER_name="#{config['name']}")
end
if config['interface']
  cluster_vars << %(cw_CLUSTER_iface="#{config['interface']}")
end
cluster_vars << %(cw_CLUSTER_quorum="#{config['quorum'] || 1}")
cluster_vars << %(cw_CLUSTER_service_url="#{config['service_url']}")
write_file('cluster.vars.sh', cluster_vars.join("\n"))
write_file('config.rc', cluster_vars.join("\n"))

auth_vars = []
if config['token']
  auth_vars << %(cw_CLUSTER_auth_token="#{config['token']}")
end
write_file('auth.rc', auth_vars.join("\n"), perm: 0600)

instance_vars = []
instance_vars << %(cw_INSTANCE_role="#{config['role']}")
instance_vars << %(cw_INSTANCE_log="#{config['log'] || '/var/log/clusterware/instance.log'}")
tags.each do |k,v|
  instance_vars << %(cw_INSTANCE_tag_#{k.upcase.tr('-','_')}="#{v}")
end
write_file('instance.vars.sh', instance_vars.join("\n"))
write_file('instance.rc', instance_vars.join("\n"))
RUBY

    cp -p "${cw_ROOT}/etc/config/cluster/serf"/*.json "${cw_ROOT}/etc/serf"

    files_load_config instance config/cluster
    if [ "${cw_INSTANCE_role}" == "master" ]; then
        echo "Installing Clusterware periodic cronjob: ${cw_ROOT}/libexec/share/trigger-periodic"
        echo "*/5 * * * * root ${cw_ROOT}/libexec/share/trigger-event periodic >/dev/null 2>&1" > /etc/cron.d/clusterware-clusterable-trigger-periodic

        if [ -f "${cw_ROOT}"/etc/genders ]; then
            short_name="$(hostname -s)"
            if ! grep -q "^${short_name}" "${cw_ROOT}"/etc/genders; then
                echo "${short_name} master,masters,cluster,all" >> "${cw_ROOT}"/etc/genders
            fi
        fi
    fi
    _setup_aws
}

setup

require ruby
require distro
require handler
require member
require files
require network

_JQ="${cw_ROOT}"/opt/jq/bin/jq
_JO="${cw_ROOT}"/opt/jo/bin/jo

handler_tee main "$@"
